<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android NDK 使用 Address Sanitizer</title>
    <url>/2021/09/13/Android-NDK-%E4%BD%BF%E7%94%A8-Address-Sanitizer/</url>
    <content><![CDATA[<p>从 API 级别 27 (Android O MR 1) 开始，Android NDK 支持 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</a>（也称为 ASan）。ASan 是一种基于编译器的快速检测工具，用于检测C/C++代码中的内存错误。ASan 的 CPU 开销约为 2 倍，代码大小开销在 50% 到 2 倍之间，并且内存开销很大。</p>
<p><strong>注意: Android 平台不支持检测内存泄漏！！！</strong></p>
<span id="more"></span> 

<p>ASan 可以检测以下问题：</p>
<ul>
<li>堆栈和堆缓冲区上溢/下溢</li>
<li>释放之后的堆使用情况</li>
<li>超出范围的堆栈使用情况</li>
<li>重复释放/错误释放</li>
</ul>
<p>ASan 可在 32 位和 64 位 ARM 以及 x86 和 x86-64 上运行。Android NDK 也支持 <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">HWAddress Sanitizer</a>（也称为 HWASan）。与ASan 相比，HWASan功能类似，开销较小，但是使用麻烦。</p>
<ul>
<li>NDK r21 和 Android 10（API 级别 29）以上</li>
<li>HWASan 仅适用于 64 位 Arm 设备</li>
<li>HWASan 应用需要将预构建的映像刷写到支持的 Pixel 手机上。</li>
</ul>
<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>如需使用 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</a> 构建应用的原生 (JNI) 代码，请执行以下操作：</p>
<p>Quote from: <a href="https://developer.android.com/ndk/guides/asan#building">https://developer.android.com/ndk/guides/asan#building</a></p>
<blockquote>
<p>1.在模块的 <code>build.gradle</code> 中：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> defaultConfig &#123;</span><br><span class="line">     externalNativeBuild &#123;</span><br><span class="line">         cmake &#123;</span><br><span class="line">             # Can also use system or none as ANDROID_STL.</span><br><span class="line">             arguments <span class="string">&quot;-DANDROID_ARM_MODE=arm&quot;</span>, <span class="string">&quot;-DANDROID_STL=c++_shared&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.对于 <code>CMakeLists.txt</code> 中的每个目标：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(<span class="variable">$&#123;TARGET&#125;</span> PUBLIC -fsanitize=address -fno-omit-frame-pointer)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;TARGET&#125;</span> PROPERTIES LINK_FLAGS -fsanitize=address)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>还可以添加开关，只在debug版本中开启该功能：</p>
<p>在模块的 <code>build.gradle</code> 中:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake &#123;</span><br><span class="line">    arguments <span class="string">&quot;-DANDROID_STL=c++_shared&quot;</span>, <span class="string">&quot;-DSANITIZE=TRUE&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模块的 <code>CMakeLists.txt</code> 中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable address sanitizer only for debug builds</span><br><span class="line">if (SANITIZE)</span><br><span class="line">	...</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>还可以使用如下配置:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fsanitize=address -fno-omit-frame-pointer&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fsanitize=address -fno-omit-frame-pointer&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -fsanitize=address&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_ANDROID_ARM_MODE ARM)</span><br></pre></td></tr></table></figure>

<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>ASan需要在进程启动时启用，要求以全新的进程来运行应用，而不是从 zygote 克隆。从 Android O MR1（API 级别 27）开始，可替换应用进程的<a href="https://developer.android.com/ndk/guides/wrap-script">封装 Shell 脚本</a>。这样可调试的应用就可对其应用启动过程进行自定义，以便在生产设备上使用 ASan。</p>
<p>Quote from: <a href="https://developer.android.com/ndk/guides/asan#running">https://developer.android.com/ndk/guides/asan#running</a></p>
<blockquote>
<ol>
<li><p>将 <code>android:debuggable</code> 和 <code>android:extractNativeLibs=true</code> 添加到应用清单。请注意，后者是某些配置的默认设置。如需了解详情，请参阅<a href="https://developer.android.com/ndk/guides/wrap-script">封装 Shell 脚本</a>。</p>
</li>
<li><p>将 ASan 运行时库添加到应用模块的 <code>jniLibs</code> 中。</p>
</li>
<li><p>将包含以下内容的 <code>wrap.sh</code> 文件添加到每个相同的目录中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line">HERE=<span class="string">&quot;<span class="subst">$(cd <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=log_to_syslog=<span class="literal">false</span>,allow_user_segv_handler=1</span><br><span class="line">ASAN_LIB=$(ls <span class="variable">$HERE</span>/libclang_rt.asan-*-android.so)</span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$HERE</span>/libc++_shared.so&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Workaround for https://github.com/android-ndk/ndk/issues/988.</span></span><br><span class="line">    <span class="built_in">export</span> LD_PRELOAD=<span class="string">&quot;<span class="variable">$ASAN_LIB</span> <span class="variable">$HERE</span>/libc++_shared.so&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">export</span> LD_PRELOAD=<span class="string">&quot;<span class="variable">$ASAN_LIB</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h3><p>目前发现， <code>android:debuggable</code> 默认是 <code>&quot;false&quot;</code>，即使不设置为 <code>&quot;true&quot;</code>，也不影响结果。</p>
<p>如果没有在 <code>AndroidManifest.xml</code>配置， <code>android:extractNativeLibs</code>默认值是 <code>&quot;true&quot;</code>。</p>
<p><em><strong>注意：</strong></em>如果使用app bundle, Android Gradle 插件从<a href="https://developer.android.com/studio/releases/gradle-plugin#3-6-0">3.6.0</a> 默认会将 <code>extractNativeLibs</code> 设置为 <code>&quot;false&quot;</code>。也就是说，原生库将保持页面对齐状态并以未压缩的形式打包。</p>
<h3 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h3><p>除了手动拷贝，还可以使用下面的两种方法：</p>
<p>(1)在<code>CMakeLists.txt</code>中添加如下配置, 自动拷贝<code>*.asan*$&#123;ARCH&#125;*-android.so</code>, 需要设置库的名称<em>LibraryName</em>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIBNAME <span class="string">&quot;LibraryName&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A function to retrieve the architecture from the ABI</span></span><br><span class="line"><span class="comment"># (neither ANDROID_ARCH_NAME nor CMAKE_SYSTEM_PROCESSOR work for this)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>(get_architecture ABI ARCH)</span><br><span class="line">    <span class="keyword">if</span> (ABI <span class="keyword">STREQUAL</span> armeabi-v7a)</span><br><span class="line">        <span class="keyword">set</span>(<span class="variable">$&#123;ARCH&#125;</span> arm PARENT_SCOPE)</span><br><span class="line">    <span class="keyword">elseif</span>(ABI <span class="keyword">STREQUAL</span> arm64-v8a)</span><br><span class="line">        <span class="keyword">set</span>(<span class="variable">$&#123;ARCH&#125;</span> aarch64 PARENT_SCOPE)</span><br><span class="line">    <span class="keyword">elseif</span>(ABI <span class="keyword">STREQUAL</span> x86)</span><br><span class="line">        <span class="keyword">set</span>(<span class="variable">$&#123;ARCH&#125;</span> i686 PARENT_SCOPE)</span><br><span class="line">    <span class="keyword">elseif</span>(ABI <span class="keyword">STREQUAL</span> x86_64)</span><br><span class="line">        <span class="keyword">set</span>(<span class="variable">$&#123;ARCH&#125;</span> x86_64 PARENT_SCOPE)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Unsupported ABI&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Asan libs are &quot;somewhere&quot; in the toolchain&#x27;s root, we try to find the</span></span><br><span class="line"><span class="comment"># right one for the current architecture and copy it to the libs output dir</span></span><br><span class="line"><span class="comment"># (so that it will be packed in the apk):</span></span><br><span class="line"></span><br><span class="line">get_architecture(<span class="variable">$&#123;ANDROID_ABI&#125;</span> ARCH)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE ASAN_SRC <span class="variable">$&#123;ANDROID_TOOLCHAIN_ROOT&#125;</span>/*.asan*<span class="variable">$&#123;ARCH&#125;</span>*-android.so)</span><br><span class="line"><span class="keyword">set</span>(ASAN_DEST <span class="variable">$&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">        <span class="keyword">TARGET</span> <span class="variable">$&#123;LIBNAME&#125;</span> PRE_BUILD</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="variable">$&#123;ASAN_SRC&#125;</span> <span class="variable">$&#123;ASAN_DEST&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>(2)使用<code>asan_device_setup</code>，将<code>*.asan*$&#123;ARCH&#125;*-android.so</code>添加到设备，设备需要root。</p>
<p>Mac 系统下，其路径为<code>ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/bin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ./asan_device_setup --<span class="built_in">help</span>                                                                                     </span><br><span class="line">usage: ./asan_device_setup [--revert] [--device device-id] [--lib path] [--extra-options options]</span><br><span class="line">  --revert: Uninstall ASan from the device.</span><br><span class="line">  --lib: Path to ASan runtime library.</span><br><span class="line">  --extra-options: Extra ASAN_OPTIONS.</span><br><span class="line">  --device: Install to the given device. Use <span class="string">&#x27;adb devices&#x27;</span> to find</span><br><span class="line">            device-id.</span><br><span class="line">  --use-su: Use <span class="string">&#x27;su -c&#x27;</span> prefix <span class="keyword">for</span> every adb <span class="built_in">command</span> instead of using</span><br><span class="line">            <span class="string">&#x27;adb root&#x27;</span> once.</span><br></pre></td></tr></table></figure>

<p>如果执行成功，那么设备就会自动重启，测试完成最好移除这些库。</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>NDK包含一个推荐的针对ASan的<a href="https://android.googlesource.com/platform/ndk/+/refs/heads/master/wrap.sh/asan.sh">wrap.sh文件</a>。</p>
<p>Mac 系统下，其路径为<code>ANDROID_NDK_HOME/wrap.sh/asan.sh</code></p>
<p>将<code>asan.sh</code>重命名为<code>wrap.sh</code>，在模块的跟目录下添加  <code>wrap</code>, 目录结构应包含以下内容 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project root&gt;</span><br><span class="line">└── app</span><br><span class="line">    ├── src</span><br><span class="line">    │   ├── main</span><br><span class="line">    │   │   ├── AndroidManifest.xml</span><br><span class="line">    │   │   ├── java</span><br><span class="line">    │   │   ├── cpp</span><br><span class="line">    │   │   └── res</span><br><span class="line">    │   ├── androidTest</span><br><span class="line">    │   └── test</span><br><span class="line">    └── wrap</span><br><span class="line">        └── lib</span><br><span class="line">            ├── arm64-v8a</span><br><span class="line">            │   └── wrap.sh</span><br><span class="line">            ├── armeabi-v7a</span><br><span class="line">            │   └── wrap.sh</span><br><span class="line">            ├── x86</span><br><span class="line">            │   └── wrap.sh</span><br><span class="line">            └── x86_64</span><br><span class="line">                └── wrap.sh</span><br></pre></td></tr></table></figure>

<p>在模块的 <code>build.gradle</code> 中添加:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            sourceSets.debug.resources.srcDir <span class="string">&quot;wrap&quot;</span></span><br><span class="line">            externalNativeBuild &#123;</span><br><span class="line">                cmake &#123;</span><br><span class="line">                    arguments <span class="string">&quot;-DANDROID_STL=c++_shared&quot;</span>, <span class="string">&quot;-DSANITIZE=TRUE&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p><a href="https://developer.android.com/ndk/guides/wrap-script">https://developer.android.com/ndk/guides/wrap-script</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.android.com/ndk/guides/asan">https://developer.android.com/ndk/guides/asan</a></p>
<p><a href="https://developer.android.com/ndk/guides/wrap-script">https://developer.android.com/ndk/guides/wrap-script</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Studio中-gitignore的配置</title>
    <url>/2016/11/15/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>如果你使用git 作版本控制工具，那么你可以轻松的使用android studio / Intellij IDEA 的.gitignore 插件来生成一份可以将这些文件排除在外的.gitignore 过滤清单。</p>
<span id="more"></span> 

<h1 id="Android-Studio-项目目录结构"><a href="#Android-Studio-项目目录结构" class="headerlink" title="Android Studio 项目目录结构"></a>Android Studio 项目目录结构</h1><p>在项目目录下找到.gitignore文件（一般有两个地方存在该文件：一是根目录下，一是app目录下）， 在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以通过配置.gitignore文件让Git不跟踪配置的文件。</p>
<p> <img src="/2016/11/15/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE1.png" alt="Android-Studio中-gitignore的配置1"></p>
<blockquote>
<p>其中：</p>
<ul>
<li>.gradle 是gradle 运行以后生成的缓存文件夹。</li>
<li>.idea 是android studio / Intellij IDEA 工程打开以后生成的工作环境配置文件夹。</li>
<li>app 文件夹是你的application module，其中包含你的源码。</li>
<li>build 文件夹为编译时的缓存文件夹，每次运行时都会生成，同时你在运行了gradle clean 的任务以后它会被删除清理掉。</li>
<li>gradle 文件夹中包含的是gradle-wrapper.jar 文件，通过配置其中的gradle-wrapper.properties 中的distributionUrl 可以给你的项目指定需要使用的gradle 版本。</li>
<li>.gitignore 文件为git 版本控制的忽略清单。</li>
<li>gradle.build 为project 全局的配置。</li>
<li>gradle.properties 为 gradle 的参数配置。</li>
<li>*.iml 文件为Android Studio / Intellij IDEA 为每一个module 生成的配置文件</li>
<li>gradlew gradlew.bat 是gradle 任务的脚本命令。</li>
<li>local.properties 中配置个人电脑环境中的配置，这不能提供给别人使用。</li>
<li>settings.gradle 文件中可指定project 目录中的任何一个文件夹为gradle 的module</li>
</ul>
</blockquote>
<h1 id="Android-开发-gitignore-的配置"><a href="#Android-开发-gitignore-的配置" class="headerlink" title="Android 开发 .gitignore 的配置"></a>Android 开发 .gitignore 的配置</h1><p>如果你使用git 作版本控制工具，那么你可以轻松的使用android studio / Intellij IDEA 的.gitignore 插件来生成一份可以将这些文件排除在外的.gitignore 过滤清单。这样在你使用git 分发代码时，这些不必要的文件将不会被提交到git server 中去。</p>
<h2 id="gitignore插件"><a href="#gitignore插件" class="headerlink" title=".gitignore插件"></a>.gitignore插件</h2><p> <img src="/2016/11/15/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE2.png" alt="Android-Studio中-gitignore的配置1"></p>
<p>打开项目目录中的.gitignore，然后使用快捷键<strong>Ctrl+N</strong>打开<strong>Generate</strong>：</p>
<p> <img src="/2016/11/15/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE3.png" alt="Android-Studio中-gitignore的配置1"></p>
<h2 id="自定义的-gitignore模板"><a href="#自定义的-gitignore模板" class="headerlink" title="自定义的.gitignore模板"></a>自定义的.gitignore模板</h2><p> <img src="/2016/11/15/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE/Android-Studio%E4%B8%AD-gitignore%E7%9A%84%E9%85%8D%E7%BD%AE4.png" alt="Android-Studio中-gitignore的配置1"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">###Android###</span></span><br><span class="line"><span class="comment"># Built application files</span></span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Files for the ART/Dalvik VM</span></span><br><span class="line">*.dex</span><br><span class="line"></span><br><span class="line"><span class="comment"># Java class files</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated files</span></span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gradle files</span></span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Local configuration file (sdk path, etc)</span></span><br><span class="line">local.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># Proguard folder generated by Eclipse</span></span><br><span class="line">proguard/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Log Files</span></span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Crashlytics plugin (for Android Studio and IntelliJ)</span></span><br><span class="line">com_crashlytics_export_strings.xml</span><br><span class="line">crashlytics.properties</span><br><span class="line">crashlytics<span class="literal">-build</span>.properties</span><br><span class="line">fabric.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Studio Navigation editor temp files</span></span><br><span class="line">.navigation/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Studio captures folder</span></span><br><span class="line">captures/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keystore files</span></span><br><span class="line">*.jks</span><br><span class="line"></span><br><span class="line"><span class="comment"># External native build folder generated in Android Studio 2.2 and later</span></span><br><span class="line">.externalNativeBuild</span><br><span class="line"></span><br><span class="line"><span class="comment">###macOS###</span></span><br><span class="line">*.DS_Store</span><br><span class="line">.AppleDouble</span><br><span class="line">.LSOverride</span><br><span class="line"></span><br><span class="line"><span class="comment"># Icon must end with two \r</span></span><br><span class="line">Icon</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Thumbnails</span></span><br><span class="line">._*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Files that might appear in the root of a volume</span></span><br><span class="line">.DocumentRevisions<span class="literal">-V100</span></span><br><span class="line">.fseventsd</span><br><span class="line">.Spotlight<span class="literal">-V100</span></span><br><span class="line">.TemporaryItems</span><br><span class="line">.Trashes</span><br><span class="line">.VolumeIcon.icns</span><br><span class="line">.com.apple.timemachine.donotpresent</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directories potentially created on remote AFP share</span></span><br><span class="line">.AppleDB</span><br><span class="line">.AppleDesktop</span><br><span class="line">Network Trash Folder</span><br><span class="line">Temporary Items</span><br><span class="line">.apdisk</span><br><span class="line"></span><br><span class="line"><span class="comment">###Linux###</span></span><br><span class="line">*~</span><br><span class="line"></span><br><span class="line"><span class="comment"># temporary files which can be created if a process still has a handle open of a deleted file</span></span><br><span class="line">.fuse_hidden*</span><br><span class="line"></span><br><span class="line"><span class="comment"># KDE directory preferences</span></span><br><span class="line">.directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux trash folder which might appear on any partition or disk</span></span><br><span class="line">.Trash-*</span><br><span class="line"></span><br><span class="line"><span class="comment"># .nfs files are created when an open file is removed but is still being accessed</span></span><br><span class="line">.nfs*</span><br><span class="line"></span><br><span class="line"><span class="comment">###Windows###</span></span><br><span class="line"><span class="comment"># Windows image file caches</span></span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line"></span><br><span class="line"><span class="comment"># Folder config file</span></span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recycle Bin used on file shares</span></span><br><span class="line"><span class="variable">$RECYCLE</span>.BIN/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows Installer files</span></span><br><span class="line">*.cab</span><br><span class="line">*.msi</span><br><span class="line">*.msm</span><br><span class="line">*.msp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows shortcuts</span></span><br><span class="line">*.lnk</span><br><span class="line"><span class="comment">###IntelliJ###</span></span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line">*.iws</span><br><span class="line">.idea/</span><br><span class="line">app/libs/</span><br></pre></td></tr></table></figure>

<h1 id="gitignore配置不生效的解决办法"><a href="#gitignore配置不生效的解决办法" class="headerlink" title=".gitignore配置不生效的解决办法"></a>.gitignore配置不生效的解决办法</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> <span class="literal">-r</span> -<span class="literal">-cached</span> .</span><br><span class="line">git add .</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;update .gitignore&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>就是先把本地缓存删除（改变成未track状态），然后再提交。</p>
</blockquote>
<h1 id="其他-gitignore的配置"><a href="#其他-gitignore的配置" class="headerlink" title="其他.gitignore的配置"></a>其他.gitignore的配置</h1><p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a>  找到它。各种配置文件，只需要组合一下就可以使用了。</p>
<p>参考文献</p>
<p>[1] <a href="https://www.zhihu.com/question/33048493">https://www.zhihu.com/question/33048493</a></p>
<p>[2] <a href="http://blog.csdn.net/watermusicyes/article/details/50348967">http://blog.csdn.net/watermusicyes/article/details/50348967</a></p>
<p>[3] <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93">https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下配置多个SSH-Key</title>
    <url>/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/</url>
    <content><![CDATA[<h1 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH-Key"></a>生成SSH-Key</h1><h2 id="打开终端，前往-ssh目录"><a href="#打开终端，前往-ssh目录" class="headerlink" title="打开终端，前往.ssh目录"></a>打开终端，前往.ssh目录</h2><p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key1.png" alt="配置多个SSH-Key1"></p>
<span id="more"></span> 

<h2 id="生成一个SSH-Key"><a href="#生成一个SSH-Key" class="headerlink" title="生成一个SSH-Key"></a>生成一个SSH-Key</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;youremail@email.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义生成key的名字"><a href="#自定义生成key的名字" class="headerlink" title="自定义生成key的名字"></a>自定义生成key的名字</h3><p><img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key2.png" alt="配置多个SSH-Key2"></p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key3.png" alt="配置多个SSH-Key3"></p>
<h3 id="成功生成SSH-Key"><a href="#成功生成SSH-Key" class="headerlink" title="成功生成SSH-Key"></a>成功生成SSH-Key</h3><p><img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key4.png" alt="配置多个SSH-Key4"></p>
<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH-Key"></a>配置SSH-Key</h3><p>在~/.ssh/目录下会生成id-rsa_hostname和id-rsa_hostname.pub私钥和公钥。 我们将id-rsa_hostname.pub中的内容粘帖到服务器的SSH-key的配置中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> id_rsa_hostname.pub</span><br></pre></td></tr></table></figure>

<p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key5.png" alt="Mac下配置多个SSH-Key5"></p>
<p>在GitHub的设置中粘贴公钥</p>
<p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key6.png" alt="Mac下配置多个SSH-Key6"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ssh <span class="literal">-T</span> git@github.com</span><br></pre></td></tr></table></figure>

<p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key7.png" alt="Mac下配置多个SSH-Key8"></p>
<h1 id="配置多个SSH-Key"><a href="#配置多个SSH-Key" class="headerlink" title="配置多个SSH-Key"></a>配置多个SSH-Key</h1><h2 id="打开Finder前往-ssh文件夹"><a href="#打开Finder前往-ssh文件夹" class="headerlink" title="打开Finder前往.ssh文件夹"></a>打开Finder前往.ssh文件夹</h2><p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key8.png" alt="Mac下配置多个SSH-Key7"></p>
<p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key9.png" alt="Mac下配置多个SSH-Key8"></p>
<h2 id="编辑config文件"><a href="#编辑config文件" class="headerlink" title="编辑config文件"></a>编辑config文件</h2><p> <img src="/2016/11/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key10.png" alt="Mac下配置多个SSH-Key8"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github <span class="comment">//github对应的私钥</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># coding.net</span></span><br><span class="line">Host git.coding.net</span><br><span class="line">User youremail.com <span class="comment">//coding对应的email</span></span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/blog <span class="comment">//coding对应的私钥</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># coding.net</span></span><br><span class="line">Host git.coding.net</span><br><span class="line">User youremail.com <span class="comment">//coding对应的email</span></span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa <span class="comment">//coding对应的私钥</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mac OS</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C/C++编译</title>
    <url>/2020/08/09/%E7%90%86%E8%A7%A3C-C-%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>编译和链接是在C/C++软件开发过程中经常发生的两个非常基本的过程，但奇怪的是，它们并没有被许多C/C++开发人员很好地理解。为什么C/C++源代码分割成头文件和源文件? 编译器是如何看到每个部分的? 这如何影响编译和链接? 还有许多类似的问题，你可能已经想过，但已经接受作为惯例。无论您是在设计C/C++应用程序、为其实现新特性、试图解决bug(尤其是某些奇怪的bug)，还是试图让C和C/C++代码协同工作，了解如何编译和链接将节省大量时间。</p>
<span id="more"></span> 

<h2 id="预处理-编译和链接"><a href="#预处理-编译和链接" class="headerlink" title="预处理 编译和链接"></a>预处理 编译和链接</h2><p><img src="/2020/08/09/%E7%90%86%E8%A7%A3C-C-%E7%BC%96%E8%AF%91/C_DevelopmentProcesses.png" alt="preprocessor_compliler_linker_loader"></p>
<p><strong>编译器</strong>（compiler）是一种<a href="https://en.wikipedia.org/wiki/Computer_program">计算机程序</a>，它会将某种编程语言写成的<a href="https://en.wikipedia.org/wiki/Programming_language">源代码</a>（原始语言）转换成另一种编程语言（目标语言）。它主要的目的是将便于人编写、阅读、维护的高级计算机语言所写作的<a href="https://en.wikipedia.org/wiki/Programming_language">源代码</a>程序，翻译为计算机能解读、运行的低阶机器语言的程序，也就是<a href="https://en.wikipedia.org/wiki/Executable">可执行文件</a>。编译器将原始程序（source program）作为输入，翻译产生使用目标语言（target language）的等价程序。<a href="https://en.wikipedia.org/wiki/Programming_language">源代码</a>一般为高级语言（High-level language），如Pascal、C、C++、C# 、Java等，而目标语言则是汇编语言或目标机器的<a href="https://en.wikipedia.org/wiki/Object_code">目标代码</a>（Object code），有时也称作<a href="https://en.wikipedia.org/wiki/Machine_code">机器代码</a>（Machine code）。</p>
<p>一个现代编译器的主要工作流程如下：</p>
<p><a href="https://en.wikipedia.org/wiki/Source_code">源代码</a>（source code）→ <a href="https://en.wikipedia.org/wiki/Preprocessor">预处理器</a>（preprocessor）→ <a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>（compiler）→ <a href="https://en.wikipedia.org/wiki/Assembly_language">汇编程序</a>（assembler）→ <a href="https://en.wikipedia.org/wiki/Object_code">目标代码</a>（object code）→ <a href="https://en.wikipedia.org/wiki/Linker_(computing)">链接器</a>（linker）→ <a href="https://en.wikipedia.org/wiki/Executable">可执行文件</a>（executables），最后打包好的文件就可以给电脑去判读运行了。</p>
<p>每个c++源文件都需要编译成目标文件。编译多个源文件产生的目标文件然后链接到可执行文件、共享库或静态库。c++源文件通常具有.cpp、.cxx或.cc扩展名后缀。c++源文件可以包含其他文件，称为头文件，使用#include指令。头文件具有.h、.hpp或.hxx这样的扩展名，或者完全没有扩展名，就像c++标准库和其他库的头文件(如Qt)中那样。扩展对于c++预处理器来说并不重要，它会将包含#include指令的行替换为所包含文件的全部内容。</p>
<p>编译器对源文件执行的第一步是在其上运行预处理器。只有源文件被传递给编译器(进行预处理和编译)。头文件不传递给编译器。相反，它们是从源文件中包含的。在所有源文件的预处理阶段，每个头文件都可以被打开多次，具体取决于有多少源文件包含了它们，或者有多少源文件中包含的其他头文件也包含了它们(可能有许多间接级别)。另一方面，编译器(和预处理器)只会在源文件被传递给编译器时打开一次。</p>
<p>对于每一个C/C++源文件, 当它发现一个#include指令时，预处理器通过插入内容将构建一个翻译单元；与此同时，若找到条件编译模块的求值结果为false时，它会剥离代码源文件和指令的头。它还将完成一些其他任务，比如宏替换。一旦预处理器完成创建(有时是巨大的)转换单元，编译器就开始编译阶段并生成目标文件。</p>
<p><a href="https://gcc.gnu.org/">GNU C和C++编译器</a>分别称为gcc和g++。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">只编译并生成目标文件。</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只运行 C 预编译器。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td align="left">-o FILE</td>
<td align="left">生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td align="left">-O0</td>
<td align="left">不进行优化处理。</td>
</tr>
<tr>
<td align="left">-O 或 -O1</td>
<td align="left">优化生成代码。</td>
</tr>
<tr>
<td align="left">-O2</td>
<td align="left">进一步优化。</td>
</tr>
<tr>
<td align="left">-O3</td>
<td align="left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">不生成任何警告信息。</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">生成所有警告信息。</td>
</tr>
</tbody></table>
<p>下面是一个示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello_c.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, C world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello_cpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello, C++ world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以下方法创建预处理文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -E hello_c.c -o hello_c.ii</span><br><span class="line">$ g++ -E hello_cpp.cpp -o hello_cpp.ii</span><br></pre></td></tr></table></figure>

<p>看行数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wc -l hello.ii</span><br><span class="line">544 hello.ii</span><br><span class="line">$ wc -l hello_cpp.ii</span><br><span class="line">41840 hello_cpp.ii</span><br></pre></td></tr></table></figure>

<p>在我的机器中hello.ii有544行代码, hello_cpp.ii有41840行代码。我们可以看到，编译器必须编译一个比我们看到的简单源文件大得多的文件。这是因为包含了头文件。在我们的示例中，我们只包含了一个header。随着我们不断包含头文件，翻译单元变得越来越大。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c hello_c.c</span><br><span class="line">$ gcc -o hello_c.out hello_c.o</span><br><span class="line">$ ./hello_c.out</span><br><span class="line">Hello, C world!</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++ -c hello_cpp.cpp</span><br><span class="line">$ g++ -o hello_cpp.out hello_cpp.o</span><br><span class="line">$ ./hello_cpp.out</span><br><span class="line">Hello, C++ world!</span><br></pre></td></tr></table></figure>

<h2 id="源文件如何导入和导出符号"><a href="#源文件如何导入和导出符号" class="headerlink" title="源文件如何导入和导出符号"></a>源文件如何导入和导出符号</h2><p>有一个简单的C(不是C++)源文件名为 print_num.c，它导出了两个函数，一个用于打印整数，另一个用于打印浮点数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printI</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">printF</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译它以创建 print_num.o 目标文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c print_num.c</span></span><br></pre></td></tr></table></figure>

<p>现在看看这个目标文件导出和导入的符号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm print_num.o</span></span><br><span class="line">0000000000000010 T _printF</span><br><span class="line">0000000000000000 T _printI</span><br></pre></td></tr></table></figure>

<p>没有符号被导入，导出两个符号 printF和printI。这些符号被导出为.text段(T)的一部分，因此它们是函数名、可执行代码。</p>
<p>标准的方法是创建一个头文件来声明它们，并将它们包含在我们想要调用的任何源文件中。头文件可以有任何名称和扩展名。下面的例子print_num.h：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printI</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">printF</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125; <span class="comment">// end extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那些ifdef/endif条件编译块是什么?如果我从C源文件中引用这个头文件，我希望它成为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printI</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">printF</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但如果如果我从C++源文件中引用这个头文件，我希望它成为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">printI</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">printF</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line">&#125; <span class="comment">// end extern &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>C语言不知道关于extern “C”指令的任何事情，但是c++知道，它需要将这个指令应用到C函数声明中。这是因为c++重整了<a href="https://en.wikipedia.org/wiki/Name_mangling">函数(和方法)的名称</a>，因为它支持函数/方法重载，而C不支持。</p>
<p>这可以在名为print.cpp的c++源文件中看到:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;print_num.h&quot;</span> <span class="comment">// printI, printF</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printNum: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;, printI: &quot;</span> &lt;&lt; <span class="built_in">printI</span>(v) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printNum: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;, printI: &quot;</span> &lt;&lt; <span class="built_in">printI</span>(v) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">printNumInt</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNum</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">printNumFloat</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNum</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个名称相同的函数(printNum)，只是它们的参数类型不同:int或float。函数重载是C++的一个特性，在C中没有。为了实现这个特性并区分这些函数，C++修改了函数名，我们可以在导出的符号名中看到(我只从nm的输出中选择相关的):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -c print.cpp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nm print.o</span> </span><br><span class="line">0000000000000140 T __Z8printNumf</span><br><span class="line">0000000000000000 T __Z8printNumi</span><br><span class="line">                 U _printF</span><br><span class="line">                 U _printI</span><br><span class="line">00000000000001d0 T _printNumFloat</span><br><span class="line">00000000000001b0 T _printNumInt</span><br><span class="line">                 U __ZNSt3__14coutE</span><br></pre></td></tr></table></figure>

<p>在我的系统中，这些函数被导出为float版本的<code>__Z8printNumf</code>和int版本的<code>__Z8printNumi</code>。C++中的每个函数名都是混乱的，除非声明为extern “C”。在print中有两个函数是用C链接声明的。printSumInt和printSumFloat。</p>
<p>因此，它们不能被重载，或者它们的导出名称将是相同的，因为它们没有被破坏。我必须通过在它们的名字后面加上整型或浮点数来区分它们。因为它们没有被破坏，所以可以从C代码中调用它们，我们很快就会看到。</p>
<p>要像在C++源代码中那样查看被破坏的名称，我们可以在nm命令中使用-C (demangle)选项。同样，我将只复制输出相同的相关部分:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm -C print.o</span></span><br><span class="line">0000000000000140 T printNum(float)</span><br><span class="line">0000000000000000 T printNum(int)</span><br><span class="line">                 U _printF</span><br><span class="line">                 U _printI</span><br><span class="line">00000000000001d0 T _printNumFloat</span><br><span class="line">00000000000001b0 T _printNumInt</span><br><span class="line">                 U std::__1::cout</span><br></pre></td></tr></table></figure>

<p>使用这个选项，我们看到的不是<code>__Z8printNumf</code>，而是printNum(float)，不是<code>__ZNSt3__14coutE</code>，而是<code>std::__1::cout</code>，这是更人性化的名称。</p>
<p>我们还看到C++代码调用了C代码:print.cpp调用了printI和pringF，它们是在print_num.h中声明为具有C链接的C函数。这可以从print.o的nm输出中看出。上面一些未定义的(U)符号:printF, printI和std::cout。那些未定义的符号应该在一个对象文件(或库)中提供，该对象文件将在链接阶段与这个对象文件输出链接在一起。</p>
<p>到目前为止，我们只是将源代码编译成目标代码，还没有链接。如果我们没有将包含这些导入符号定义的对象文件与此对象文件链接在一起，那么链接器将停止，并出现“丢失符号”错误。</p>
<p>还要注意，由于print.cpp是一个C++源文件，是用C++编译器(g++)编译的，因此其中的所有代码都被编译为C++代码。带有C链接的函数，如printNumInt和printNumFloat，也是可以使用C++特性的C++函数。只是符号的名称与C兼容，但代码是C++，这一点可以从两个函数都在调用重载函数(printNum)这一事实看出，如果在C中编译printNumInt或printNumFloat，就不会发生这种情况。</p>
<p>现在让我们看看 print.hpp，一个头文件，可以包含从C或C++源文件，它将允许从C和C++调用printNumInt和printNumFloat，以及从C++调用printNum:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">printNum</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumInt</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125; <span class="comment">// end extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们从C源文件包括它，我们只想看到:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumInt</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不能从C代码中看到printNum，因为它的名字被破坏了，所以我们没有(标准的和可移植的)方法来为C代码声明它。是的，我可以声明为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __Z8printNumi(<span class="keyword">int</span> v);</span><br><span class="line"><span class="keyword">void</span> __Z8printNumf(<span class="keyword">float</span> v);</span><br></pre></td></tr></table></figure>

<p>链接器不会抱怨，因为这正是我当前安装的编译器为它发明的名称，但我不知道它是否适用于您的链接器(如果您的编译器生成了一个不同的错误名称)，甚至适用于我的链接器的下一个版本。我甚至不知道如果调用将按预期工作,因为不同的调用约定的存在(如何传递参数和返回值返回)。 它是与具体编译器相关的,可能是不同的C和C++调用(特别是对于C++函数成员函数和接收这个指针作为参数)。</p>
<p>编译器可能会对普通C++函数使用一种调用约定，如果它们被声明为具有extern “ C “链接，则使用另一种调用约定。因此，欺骗编译器说一个函数使用C调用约定，而实际上它使用C++，同时，如果每个函数使用的约定在编译工具链中碰巧不同，可能会产生意想不到的结果。</p>
<p>混合C和C++代码有标准的方法，从C中调用C++重载函数的标准方法是将它们封装在带有C链接的函数中，就像我们用printNumInt和printNumFloat封装printNum一样。</p>
<p>如果我们在一个C++源文件中引用print.hpp，<code>__cplusplus</code>预处理器宏将被定义，该文件将被视为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumInt</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end extern &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将允许C++代码调用重载函数printNum或其封装层printNumInt和printNumFloat。</p>
<p>现在让我们创建一个包含main函数的C源文件，它是程序的入口点。这个C主函数将调用printNumInt和printNumFloat，也就是说，将使用C链接调用这两个C++函数。记住，这些是C++函数(它们的函数体执行C++代码)，只是它们的名称没有被打乱。文件命名为c-main.c:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;print.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNumInt</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printNumFloat</span>(<span class="number">1.5f</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成目标文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c c-main.c</span></span><br></pre></td></tr></table></figure>

<p>并查看导入/导出符号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm c-main.o</span></span><br><span class="line">0000000000000000 T _main</span><br><span class="line">                 U _printNumFloat</span><br><span class="line">                 U _printNumInt</span><br></pre></td></tr></table></figure>

<p>如预期的那样，它导出main并导入printNumFloat和printNumInt。</p>
<p>要将它们链接到一个可执行文件中，我们需要使用C++链接器(g++)，因为至少要链接的一个文件print.o是用c++编译的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ -o c-app print_num.o print.o c-main.o</span><br></pre></td></tr></table></figure>

<p>执行产生预期的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./c-app</span><br><span class="line">printNum: 1, printI: 1</span><br><span class="line">printNum: 1.5, printF: 1.5</span><br></pre></td></tr></table></figure>

<p>现在让我们尝试使用一个c++主文件，名为cpp-main.cpp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;print.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printNum</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printNum</span>(<span class="number">1.5f</span>);</span><br><span class="line">    <span class="built_in">printNumInt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printNumFloat</span>(<span class="number">3.5f</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并查看cpp-main的导入/导出符号 cpp-main.o对象文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ -c cpp-main.cpp</span><br><span class="line">$ nm -C cpp-main.o</span><br><span class="line">                 U printNum(float)</span><br><span class="line">                 U printNum(int)</span><br><span class="line">0000000000000000 T _main</span><br><span class="line">                 U _printNumFloat</span><br><span class="line">                 U _printNumInt</span><br></pre></td></tr></table></figure>

<p>它导出main，并导入C链接printNumFloat和printNumInt，以及两个被修改的printNum版本。</p>
<p>你可能想知道为什么主符号没有导出为一个像main(int, char**)这样的混乱符号从这个C++源文件，因为它是一个C++源文件，它没有定义为extern “C”。main是一个特殊的实现定义函数，无论它是在C或C++源文件中定义，我的实现似乎都选择使用C链接。</p>
<p>链接和运行程序会得到预期的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ -o cpp-app print_num.o print.o cpp-main.o</span><br><span class="line">$  ./cpp-app</span><br><span class="line">printNum: 1, printI: 1</span><br><span class="line">printNum: 1.5, printF: 1.5</span><br><span class="line">printNum: 3, printI: 3</span><br><span class="line">printNum: 3.5, printF: 3.5</span><br></pre></td></tr></table></figure>



<p>参考文献：</p>
<p>[1] <a href="https://en.wikipedia.org/wiki/Compiler">https://en.wikipedia.org/wiki/Compiler</a></p>
<p>[2] <a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html</a></p>
<p>[3] <a href="http://www.cplusplus.com/doc/tutorial/introduction/">http://www.cplusplus.com/doc/tutorial/introduction/</a></p>
<p>[4] <a href="https://en.cppreference.com/w/cpp/compiler_support">https://en.cppreference.com/w/cpp/compiler_support</a></p>
<p>[5] <a href="https://docs.oracle.com/cd/E19957-01/806-3572/Using.html">https://docs.oracle.com/cd/E19957-01/806-3572/Using.html</a></p>
<p>[6] <a href="https://en.wikipedia.org/wiki/Name_mangling">https://en.wikipedia.org/wiki/Name_mangling</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Android-Plugin-开发教程</title>
    <url>/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B1.png" alt="Unity-Android-Plugin-开发教程1"></p>
<center>开发环境Windows平台（Unity2017.1.0f3 Personal ，Android Studio 2.3.3）</center>

<span id="more"></span> 

<h2 id="在Unity项目中构建和使用Android-Plugin"><a href="#在Unity项目中构建和使用Android-Plugin" class="headerlink" title="在Unity项目中构建和使用Android Plugin"></a>在Unity项目中构建和使用Android Plugin</h2><blockquote>
<p><a href="https://docs.unity3d.com/2017.1/Documentation/Manual/PluginsForAndroid.html">Unity支持几种类型的Android plug-ins：</a></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B2.png" alt="Unity-Android-Plugin-开发教程1"></p>
<ol>
<li>AAR 插件 和 Android Library</li>
<li>JAR 插件</li>
<li>继承UnityPlayerActivity</li>
<li>Native(C++) 插件</li>
</ol>
</blockquote>
<p><strong>Unity Android runtime</strong></p>
<blockquote>
<p><strong>Untiy Android runtime</strong>通过继承自<strong>FrameLayout</strong>的<strong>UnityPlayer</strong>实现，<strong>UnityPlayer</strong>实现了触控，键盘输入，相机，位置等特性。虽然这个<strong>UnityPlayer</strong>实现了大部分的<strong>native</strong>功能，但它不是应用程序的入口。</p>
</blockquote>
<p>在通用的Android Unity应用程序中，程序的入口是<strong>UnityPlayerActivity</strong>。如果你看一下APK文件反编译后的AndroidManifest.xml文件，可以看到它是如何标记<strong>UnityPlayerActivity</strong>作为应用程序的Launcher的。</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B3.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p>查看Unity安装目录发现，<strong>UnityPlayerActivity</strong>的源码可以在<strong>C:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer\Source</strong>中查看。</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B4.png" alt="Unity-Android-Plugin-开发教程1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnityPlayerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> UnityPlayer mUnityPlayer; <span class="comment">// don&#x27;t change the name of this variable; referenced from native code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup activity layout</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        getWindow().setFormat(PixelFormat.RGBX_8888); <span class="comment">// &lt;--- This makes xperia play happy</span></span><br><span class="line"></span><br><span class="line">        mUnityPlayer = <span class="keyword">new</span> UnityPlayer(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mUnityPlayer);</span><br><span class="line">        mUnityPlayer.requestFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .........</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// For some reason the multiple keyevent type is not supported by the ndk.</span></span><br><span class="line">    <span class="comment">// Force event injection by overriding dispatchKeyEvent().</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_MULTIPLE)</span><br><span class="line">            <span class="keyword">return</span> mUnityPlayer.injectEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>UnityPlayerActivity</strong>继承自<strong>Activity</strong>，并且<strong>UnityPlayerActivity</strong>持有一个<strong>UnityPlayer</strong>实例。<strong>UnityPlayerActivity</strong>通过<strong>UnityPlayer</strong>分派<strong>native</strong> 事件。</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B5.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p><a href="https://docs.unity3d.com/2017.1/Documentation/Manual/AndroidUnityPlayerActivity.html">通用的Android插件开发，通过继承<strong>UnityPlayerActivity</strong></a>，并使子类成为整个应用程序的<strong>LAUNCHER</strong> <strong>Activity</strong>，接下来将介绍继承<strong>UnityPlayerActivity</strong>方式的<strong>Android Plugin</strong> 。</p>
<h2 id="继承UnityPlayerActivity方式的Android-Plugin"><a href="#继承UnityPlayerActivity方式的Android-Plugin" class="headerlink" title="继承UnityPlayerActivity方式的Android Plugin"></a>继承<strong>UnityPlayerActivity</strong>方式的<strong>Android Plugin</strong></h2><p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B6.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p><strong>Android Plugin</strong>需要包含Android项目中<strong>build</strong>后得到的<strong>app-debug.aar</strong>和<strong>Manifest.xml</strong>以及资源文件等,提供给Unity项目使用。文件存放在Unity项目中的**/Assets/Plugins/Android<strong>。Unity项目中的代码通过</strong>app-debug.aar**与封装在其中的Android代码进行交互。For more details about <strong>.aar</strong>, see <a href="https://developer.android.com/studio/projects/android-library.html#aar-contents">Android Developer Doc</a>. And for more information about <strong>“How Unity produces the Android Manifest”</strong>, see <a href="https://docs.unity3d.com/Manual/android-manifest.html">Unity Developer Doc</a></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B7.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B8.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p>那么，接下来新建Android项目，进而生成<strong>app-debug.aar</strong>文件和<strong>Manifest.xml</strong>文件。</p>
<h3 id="Android端的操作"><a href="#Android端的操作" class="headerlink" title="Android端的操作"></a>Android端的操作</h3><h4 id="新建Android-项目"><a href="#新建Android-项目" class="headerlink" title="新建Android 项目"></a>新建Android 项目</h4><p>1.将项目切换成project的视图，打开app目录下的build.gradle文件，</p>
<blockquote>
<p>1.将<strong>apply plugin: ‘com.android.application’<strong>，改成</strong>apply plugin: ‘com.android.library’</strong></p>
<p>2.然后删除<strong>applicationId</strong></p>
</blockquote>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B9.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p>2.修改<strong>Manifest.xml</strong>文件</p>
<p>在activity中添加</p>
<p><code>&lt;meta-data android:name=&quot;unityplaer.UnityActivity&quot; android:value=&quot;true&quot;/&gt;</code></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B10.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h4 id="引入Unity的classes-jar包"><a href="#引入Unity的classes-jar包" class="headerlink" title="引入Unity的classes.jar包"></a>引入Unity的<strong>classes.jar</strong>包</h4><p>从Unity 的安装目录找到unity的classes.jar包。<br>Windows目录：</p>
<p><strong>C:\ProgramFiles\Unity\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Release\classes.jar</strong><br>Mac下目录：</p>
<p><strong>/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes\classes.jar</strong><br>​将其拷贝到UnityAndroid项目app目录下的libs目录下，右键<strong>Add as library</strong>，导入之后可以发现在build.gradle中就有他的引入了。</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B11.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B12.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h4 id="编写Android项目与Unity项目交互的代码"><a href="#编写Android项目与Unity项目交互的代码" class="headerlink" title="编写Android项目与Unity项目交互的代码"></a>编写Android项目与Unity项目交互的代码</h4><p>首先需要让MainActivity继承<strong>UnityPlayerActivity</strong>,同时删除onCreate方法中的<strong>setContentView()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">UnityPlayerActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//示例1：</span></span><br><span class="line">    <span class="comment">//Unity端调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowToast</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 需要在UI线程下执行</span></span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getApplicationContext(),msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>).setMessage(msg).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//示例2：</span></span><br><span class="line">    <span class="comment">//Unity端调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnityText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getApplicationContext(),<span class="string">&quot;Android 端调用setText&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">//调用Unity端函数</span></span><br><span class="line">                UnityPlayer.UnitySendMessage(<span class="string">&quot;Canvas&quot;</span>,<span class="string">&quot;setText&quot;</span>,<span class="string">&quot;Android 端调用setText&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Build得到app-debug-aar文件和Manifest-xml文件"><a href="#Build得到app-debug-aar文件和Manifest-xml文件" class="headerlink" title="Build得到app-debug.aar文件和Manifest.xml文件"></a>Build得到<strong>app-debug.aar</strong>文件和<strong>Manifest.xml</strong>文件</h4><p>分别在/app/build/outputs/aar和/app/src/main目录下</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B13.png" alt="Unity-Android-Plugin-开发教程1"></p>
<p>接下来需要将<strong>app-debug.aar</strong>用解压软件打开，并且删除<strong>libs</strong>目录下的<strong>classes.jar</strong></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B14.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h3 id="Unity端的操作"><a href="#Unity端的操作" class="headerlink" title="Unity端的操作"></a>Unity端的操作</h3><h4 id="创建Unity项目"><a href="#创建Unity项目" class="headerlink" title="创建Unity项目"></a>创建Unity项目</h4><p>新建Unity项目，并新建如下目录将Android端得到的<strong>app-debug.aar</strong>文件和<strong>Manifest.xml</strong>文件放在**/Plugins/Android**目录下,同时在Hierarchy下按照图示新建Canvas,Button和Text：</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B15.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h4 id="编写C-脚本"><a href="#编写C-脚本" class="headerlink" title="编写C#脚本"></a>编写C#脚本</h4><p>同时新建名为AndroidTest.cs的C#脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class AndroidTest : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Use this for initialization</span><br><span class="line">    void Start () &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// Update is called once per frame</span><br><span class="line">	void Update () &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public void BtnShowMessage()</span><br><span class="line">	&#123;</span><br><span class="line">        using (AndroidJavaClass jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            using(AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                // 调用Android端方法</span><br><span class="line">                jo.Call(&quot;ShowToast&quot;, &quot;Unity调用了Android中的AlertDialog&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    public void BtnSetText()</span><br><span class="line">    &#123;</span><br><span class="line">        using (AndroidJavaClass jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            using (AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                // 调用Android端方法</span><br><span class="line">                jo.Call(&quot;setUnityText&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//Android端调用该方法</span><br><span class="line">	public void setText(string result)&#123;</span><br><span class="line">		Text text = GameObject.Find (&quot;UnityText&quot;).GetComponent&lt;Text&gt; ();</span><br><span class="line">		text.text = result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>按照标号步骤进行1. 选择Build的平台-&gt;-&gt;2. 添加<strong>Scenes</strong> -&gt;-&gt; 3. 设置<strong>Identification</strong> -&gt;-&gt; 4. 设置包名和 API Level -&gt;-&gt; 5. 编译运行</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B16.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B1.gif" alt="Unity-Android-Plugin-开发教程1"></p>
<h2 id="使用AAR或JAR方式的Android-Plugin"><a href="#使用AAR或JAR方式的Android-Plugin" class="headerlink" title="使用AAR或JAR方式的Android Plugin"></a>使用<strong>AAR</strong>或<strong>JAR</strong>方式的<strong>Android Plugin</strong></h2><h3 id="Android端的操作-1"><a href="#Android端的操作-1" class="headerlink" title="Android端的操作"></a>Android端的操作</h3><h4 id="在Android-Studio中新建项目"><a href="#在Android-Studio中新建项目" class="headerlink" title="在Android Studio中新建项目"></a>在Android Studio中新建项目</h4><p>1.选择<strong>Add No Activity</strong></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B17.png" alt="Unity-Android-Plugin-开发教程1"></p>
<ol>
<li>新建<strong>Modue</strong>，选择<strong>Android Library</strong></li>
</ol>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B18.png" alt="Unity-Android-Plugin-开发教程1"></p>
<ol>
<li><p>添加<strong>AndroidPlugin.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.os.BatteryManager;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidPlugin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Needed to get the battery level.</span></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidPlugin</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the battery level as a float between 0 and 1 (1 being fully charged, 0 fulled discharged)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">GetBatteryPct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Intent batteryStatus = GetBatteryStatusIntent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> batteryPct = level / (<span class="keyword">float</span>)scale;</span><br><span class="line">        <span class="keyword">return</span> batteryPct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether or not we&#x27;re currently on charge</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBatteryCharging</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Intent batteryStatus = GetBatteryStatusIntent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Intent <span class="title">GetBatteryStatusIntent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IntentFilter ifilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        <span class="keyword">return</span> context.registerReceiver(<span class="keyword">null</span>, ifilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get System Time</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSysTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Build Module之后，在模块的子目录**/build/outputs/arr<strong>中得到</strong>.aar** 和 <strong>.jar</strong></p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B19.png" alt="Unity-Android-Plugin-开发教程1"></p>
</li>
</ol>
<h3 id="Unity端的操作-1"><a href="#Unity端的操作-1" class="headerlink" title="Unity端的操作"></a>Unity端的操作</h3><h4 id="创建Unity项目-1"><a href="#创建Unity项目-1" class="headerlink" title="创建Unity项目"></a>创建Unity项目</h4><p>将得到的**.arr**(将**.arr<strong>解压就可以得到</strong>.jar**) 放在<strong>Assert</strong>目录下，可以放在任意的目录下，<a href="https://docs.unity3d.com/2017.1/Documentation/Manual/AndroidAARPlugins.html">官方推荐使用**.aar**</a> 。并且按照如下目录新建Canvas和Text。</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B20.png" alt="Unity-Android-Plugin-开发教程1"></p>
<h4 id="编写C-脚本-1"><a href="#编写C-脚本-1" class="headerlink" title="编写C#脚本"></a>编写C#脚本</h4><p>编写<strong>BatteryLevelPlugin.cs</strong> :</p>
<blockquote>
<p><a href="https://docs.unity3d.com/2017.1/Documentation/Manual/AndroidJARPlugins.html">Unity提供了两种方式与java进行交互</a></p>
<ol>
<li><p>AndroidJNI 和 AndroidJNIHelper </p>
</li>
<li><p>AndroidJavaClass , AndroidJavaObject 和 AndroidJavaProxy</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B21.png" alt="Unity-Android-Plugin-开发教程1"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>同时，官方推荐如下调用方式：</p>
<p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B22.png" alt="Unity-Android-Plugin-开发教程1"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatteryLevelPlugin</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetBatteryLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Application.platform == RuntimePlatform.Android)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">using</span></span> (var javaUnityPlayer = <span class="keyword">new</span> <span class="built_in">AndroidJavaClass</span>(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">using</span></span> (var currentActivity = javaUnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in"><span class="keyword">using</span></span> (var androidPlugin = <span class="keyword">new</span> <span class="built_in">AndroidJavaObject</span>(<span class="string">&quot;com.hiscene.androidsysinfo.AndroidPlugin&quot;</span>, currentActivity))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> androidPlugin.Call&lt;<span class="keyword">float</span>&gt;(<span class="string">&quot;GetBatteryPct&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">GetSysTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AndroidJNI.<span class="built_in">AttachCurrentThread</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntPtr javaClass = AndroidJNI.<span class="built_in">FindClass</span>(<span class="string">&quot;com/unity3d/player/UnityPlayer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IntPtr fid = AndroidJNI.<span class="built_in">GetStaticFieldID</span>(javaClass, <span class="string">&quot;currentActivity&quot;</span>, <span class="string">&quot;Landroid/app/Activity;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IntPtr obj = AndroidJNI.<span class="built_in">GetStaticObjectField</span>(javaClass, fid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntPtr pluginClass = AndroidJNI.<span class="built_in">FindClass</span>(<span class="string">&quot;com/hiscene/androidsysinfo/AndroidPlugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IntPtr initMethod = AndroidJNI.<span class="built_in">GetMethodID</span>(pluginClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Landroid/content/Context;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jvalue[] jv = <span class="keyword">new</span> jvalue[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        </span><br><span class="line">        IntPtr pobj = AndroidJNI.<span class="built_in">NewObject</span>(pluginClass, initMethod,jv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntPtr enableMethod = AndroidJNI.<span class="built_in">GetMethodID</span>(pluginClass, <span class="string">&quot;getSysTime&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AndroidJNI.<span class="built_in">CallStringMethod</span>(pobj, enableMethod, <span class="keyword">new</span> jvalue[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">GetSysTimeAndroidJNI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        AndroidJNI.<span class="built_in">AttachCurrentThread</span>();</span><br><span class="line"></span><br><span class="line">        IntPtr javaClass = AndroidJNI.<span class="built_in">FindClass</span>(<span class="string">&quot;com/hiscene/androidsysinfo/SysTime&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IntPtr initMethod = AndroidJNI.<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntPtr pobj = AndroidJNI.<span class="built_in">NewObject</span>(javaClass, initMethod, AndroidJNIHelper.<span class="built_in">CreateJNIArgArray</span>(<span class="keyword">new</span> object[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntPtr enableMethod = AndroidJNI.<span class="built_in">GetMethodID</span>(javaClass, <span class="string">&quot;getSysTime&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AndroidJNI.<span class="built_in">CallStringMethod</span>(pobj, enableMethod, <span class="keyword">new</span> jvalue[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//方式二：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">GetSysTimeAndroidJavaClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Application.platform == RuntimePlatform.Android)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">using</span></span> (var javaUnityPlayer = <span class="keyword">new</span> <span class="built_in">AndroidJavaClass</span>(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">using</span></span> (var currentActivity = javaUnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in"><span class="keyword">using</span></span> (var androidPlugin = <span class="keyword">new</span> <span class="built_in">AndroidJavaObject</span>(<span class="string">&quot;com.hiscene.androidsysinfo.AndroidPlugin&quot;</span>, currentActivity))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> androidPlugin.Call&lt;string&gt;(<span class="string">&quot;getSysTime&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Time yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编写<strong>BatteryMonitor.cs</strong> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatteryMonitor</span> :</span> MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Text batteryLevelText;</span><br><span class="line">    <span class="keyword">public</span> Text batteryLevelIcon;</span><br><span class="line">    <span class="keyword">public</span> Text sysTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> readonly string BATTERY_LEVEL_100 = Char.<span class="built_in">ConvertFromUtf32</span>(<span class="number">0xf240</span>);</span><br><span class="line">    <span class="keyword">static</span> readonly string BATTERY_LEVEL_75 = Char.<span class="built_in">ConvertFromUtf32</span>(<span class="number">0xf241</span>);</span><br><span class="line">    <span class="keyword">static</span> readonly string BATTERY_LEVEL_50 = Char.<span class="built_in">ConvertFromUtf32</span>(<span class="number">0xf242</span>);</span><br><span class="line">    <span class="keyword">static</span> readonly string BATTERY_LEVEL_25 = Char.<span class="built_in">ConvertFromUtf32</span>(<span class="number">0xf243</span>);</span><br><span class="line">    <span class="keyword">static</span> readonly string BATTERY_LEVEL_0 = Char.<span class="built_in">ConvertFromUtf32</span>(<span class="number">0xf244</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">UpdateStatusIndicators</span>();</span><br><span class="line">        sysTime.text = BatteryLevelPlugin.<span class="built_in">GetSysTime</span>();</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateStatusIndicators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var currentBatteryLevel = BatteryLevelPlugin.<span class="built_in">GetBatteryLevel</span>() * <span class="number">100f</span>;</span><br><span class="line">        batteryLevelText.text = String.<span class="built_in">Format</span>(<span class="string">&quot;&#123;0&#125;%&quot;</span>, currentBatteryLevel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show the icon that matches the current level most closely.</span></span><br><span class="line">        <span class="keyword">if</span> (currentBatteryLevel &gt;= <span class="number">88</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            batteryLevelIcon.text = BATTERY_LEVEL_100;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentBatteryLevel &gt;= <span class="number">63</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            batteryLevelIcon.text = BATTERY_LEVEL_75;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentBatteryLevel &gt;= <span class="number">38</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            batteryLevelIcon.text = BATTERY_LEVEL_50;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentBatteryLevel &gt;= <span class="number">13</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            batteryLevelIcon.text = BATTERY_LEVEL_25;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            batteryLevelIcon.text = BATTERY_LEVEL_0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="按照步骤编译运行"><a href="#按照步骤编译运行" class="headerlink" title="按照步骤编译运行"></a>按照步骤编译运行</h4><p>步骤：1. 选择Build的平台-&gt;-&gt;2. 添加<strong>Scenes</strong> -&gt;-&gt; 3. 设置<strong>Identification</strong> -&gt;-&gt; 4. 设置包名和 API Level -&gt;-&gt; 5. 编译运行</p>
<h4 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="/2017/07/28/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/Unity-Android-Plugin-%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B2.gif" alt="Unity-Android-Plugin-开发教程1"></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/Rolyyu/UnityAndroidPlugin">https://github.com/Rolyyu/UnityAndroidPlugin</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://docs.unity3d.com/Manual/PluginsForAndroid.html">[1] https://docs.unity3d.com/Manual/PluginsForAndroid.html</a></p>
<p><a href="http://www.voidcn.com/blog/Silk2018/article/p-6632911.html">[2] http://www.voidcn.com/blog/Silk2018/article/p-6632911.html</a></p>
<p><a href="http://blog.csdn.net/zhangdi2017/article/details/65629589">[3] http://blog.csdn.net/zhangdi2017/article/details/65629589</a></p>
<p><a href="https://www.yangzhenlin.com/unity-android-plugin/">[4] https://www.yangzhenlin.com/unity-android-plugin/</a></p>
<p><a href="https://medium.com/@datdeveloper/how-to-make-android-plugin-for-unity-take-photo-from-camera-and-gallery-c12fe247c770">[5] https://medium.com/@datdeveloper/how-to-make-android-plugin-for-unity-take-photo-from-camera-and-gallery-c12fe247c770</a></p>
<p><a href="http://addcomponent.com/android-native-plugin-unity/">[6] http://addcomponent.com/android-native-plugin-unity/</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制</title>
    <url>/2016/08/27/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​    消息驱动模式是android提供的用来更新UI的一套机制，即消息处理的机制，类似于Windows的消息机制，所有的外部来的按键消息、触屏消息、各种系统Intent、广播等都转化为内部消息，然后在主线程中分发处理。在Windows的消息处理模型中，存在一个系统消息队列，这个队列是整个进程的核心，几乎所有的动作都要转化成消息，然后放在队列中，消息的处理只能在主线程中完成。Android的消息处理则不太一样。Android没有全局的消息队列，消息队列是和某个线程关联在一起的。每个线程最多有一个消息队列，消息的取出和处理在线程中完成。</p>
<span id="more"></span> 

<h2 id="为什么要是用消息机制"><a href="#为什么要是用消息机制" class="headerlink" title="为什么要是用消息机制"></a>为什么要是用消息机制</h2><p>​    Android在一个程序启动后会创建一个主线程，也叫<em><strong>UI线程（非线程安全）</strong></em>这个线程主要负责监听屏幕点击事件与界面绘制，不可以直接在子线程修改UI。之所以设计成单线程模型的UI主线程，是因为多个线程访问UI可能会导致冲突，造成界面显示错乱，例如，子线程A和子线程B同时修改一个组件的尺寸和背景等资源的情况,如果非要用多线程同步加锁机制更新UI又会导致性能下降。Android在设计的时候，提供了一种异步回调机制，在子线程中用Handler通知UI线程显示、更新UI。同时，Android系统也会将大部分耗时的任务（<em>网络访问</em>，<em>访问数据库</em>）交给子线程处理，当子线程完成任务将通过Handler将结果回传给UI线程，显示任务的结果。这种机制同时避免的***<a href="http://baike.baidu.com/link?url=aHush5JzReN-AIIuYstXNJ53HHkAtOIwZ2qGxiTrKQLquLdcQOPfjq8kBLlsTusJlpLwxkI6u4vuxP0fZZgvXK">ANR（Application Not Responding）</a>***，即应用无响应。</p>
<h2 id="消息机制涉及的类"><a href="#消息机制涉及的类" class="headerlink" title="消息机制涉及的类"></a>消息机制涉及的类</h2><blockquote>
<p><em><strong>Looper</strong></em> : 消息循环，<em>Looper</em>内部有一个消息队列<em>MessageQueue</em>，默认情况下一个线程不包含一个消息循环，需要自己去创建，调用**Looper.prepare()<strong>创建一个消息循环，调用</strong>Looper.Looper()*<em>执行这个循环，Android启动时，为</em>主线程(UI线程)<em>创建了一个</em>Looper*对象。</p>
</blockquote>
<hr>
<blockquote>
<p><em><strong>Message</strong></em> ：消息，定义一个包含描述和任意数据对象的消息发送给一个<em>Handler</em>，包含两个<strong>int</strong>数据区域和一个对象数据区域。消息的创建最好用<strong>Message.obtain()<strong>或</strong>Handler.obtainMessage()</strong> 方法，从一个消息池中回收。</p>
</blockquote>
<hr>
<blockquote>
<p><em><strong>MessageQueue</strong></em> ：消息队列，持有一个<strong>Looper</strong>分发的消息列表，<strong>Message</strong>不是直接添加到消息队列里的，是添加到<strong>Handler</strong>对象绑定的<strong>Looper</strong>的对象中。</p>
</blockquote>
<hr>
<blockquote>
<p><em><strong>Handler</strong></em> : 发送和处理消息（<em>Message</em>和<em>Runnable</em>对象），与一个线程的<em>MessageQueue</em>关联。一个<em>Handler</em>实例与一个线程（包括线程的消息队列）绑定。当一个<em>Handler</em>实例被创建时，该实例与创建它的<em><strong>线程/线程的消息队列</strong></em> 绑定到一起，然后向该消息队列发送<em>Message</em>和<em>Runnable</em>,并且当发送的<em>Message</em>和<em>Runnable</em>从消息队列返回时处理它们。</p>
</blockquote>
<h1 id="Looper类"><a href="#Looper类" class="headerlink" title="Looper类"></a>Looper类</h1><h2 id="主要成员和方法"><a href="#主要成员和方法" class="headerlink" title="主要成员和方法"></a>主要成员和方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  </span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare()"></a>prepare()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    每一个线程只能有一个<strong>Looper</strong>类的实例对象，Looper类的实例必须通过<strong>prepare()<strong>方法来创建。</strong>prepare()<strong>方法会创建一个</strong>Looper</strong>对象，并把它保存在静态变量<strong>mTreadLocal</strong>中，一个线程多次调用**prepare()**会抛出异常。</p>
<h2 id="静态变量sThreadLocal"><a href="#静态变量sThreadLocal" class="headerlink" title="静态变量sThreadLocal"></a>静态变量sThreadLocal</h2><p>​    该变量是一个<a href="http://blog.csdn.net/lufeng20/article/details/24314381">ThreadLocal</a>类型，即线程本地存储区（TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。它通过将需要保存的对象和线程id关联在一起的方式实现了线程本地存储功能，作用就是将Looper类线程隔离，保证每个线程只能有一个Looper对象。</p>
<p><strong>ThreadLocal.set(T value):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line"><span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象</span></span><br><span class="line"> values = initializeValues(currentThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存数据value到当前线程this</span></span><br><span class="line">values.put(<span class="keyword">this</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal.get():</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">   Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">   <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">       Object[] table = values.table;</span><br><span class="line">       <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">           <span class="keyword">return</span> (T) table[index + <span class="number">1</span>]; <span class="comment">//返回当前线程储存区中的数据</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//创建Values对象</span></span><br><span class="line">       values = initializeValues(currentThread);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>); <span class="comment">//从目标线程存储区没有查询是则返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取本地存储区的Looper对象</span></span><br><span class="line">		……</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//消息队列</span></span><br><span class="line">		……</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block，这里可能阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//没有消息退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//消息分发</span></span><br><span class="line">				……</span><br><span class="line">        msg.recycleUnchecked();<span class="comment">//消息回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>loop()<strong>是一个静态方法，其中有一个无限的</strong>for</strong>循环，<strong>loop()<strong>方法会循环从消息队列</strong>MessageQueue</strong>中取出消息，然后分发出去。消息的分发是通过<strong>Message</strong>中的<strong>target</strong>变量完成的，这个变量是<strong>Handler</strong>类型的，一个<strong>Looper</strong>对象可以对应多个<strong>Handler</strong>对象。</p>
<h1 id="Message类"><a href="#Message类" class="headerlink" title="Message类"></a>Message类</h1><p>​    <strong>Message</strong>是消息的载体。<strong>Message</strong>设计成了<strong>Parelable</strong>类的派生类，表明<strong>Message</strong>可以通过<strong>binder</strong>来跨进程发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span></span><br></pre></td></tr></table></figure>

<h2 id="消息的类型"><a href="#消息的类型" class="headerlink" title="消息的类型"></a>消息的类型</h2><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>注解</th>
</tr>
</thead>
<tbody><tr>
<td>what</td>
<td>int</td>
<td>消息类别</td>
</tr>
<tr>
<td>when</td>
<td>long</td>
<td>消息触发时间</td>
</tr>
<tr>
<td>arg1</td>
<td>int</td>
<td>参数1</td>
</tr>
<tr>
<td>arg2</td>
<td>int</td>
<td>参数2</td>
</tr>
<tr>
<td>obj</td>
<td>Object</td>
<td>消息内容</td>
</tr>
<tr>
<td>target</td>
<td>Handler</td>
<td>消息相应的地方</td>
</tr>
<tr>
<td>callback</td>
<td>Runnable</td>
<td>回调方法</td>
</tr>
</tbody></table>
<h2 id="obtain"><a href="#obtain" class="headerlink" title="obtain()"></a>obtain()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;<span class="comment">//从消息池中返回一个新的Message实例，避免申请太多的Message</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;<span class="comment">//消息池中有从消息池中取出</span></span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="recycle"><a href="#recycle" class="headerlink" title="recycle()"></a>recycle()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;<span class="comment">//回收消息</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">//判断消息是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();<span class="comment">//回收没有使用的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MessageQueue类"><a href="#MessageQueue类" class="headerlink" title="MessageQueue类"></a>MessageQueue类</h1><h2 id="消息的构造"><a href="#消息的构造" class="headerlink" title="消息的构造"></a>消息的构造</h2><blockquote>
<p><strong>MessageQueue</strong>对象的构造是调用本地方法<strong>nativeInit()<strong>完成的。</strong>nativeInit()<strong>创建了一个本地</strong>NativeMessageQueue</strong>，它本质上是一个代理类。它把<strong>Java</strong>层的调用转变为<strong>native</strong>层<strong>Looper</strong>类的函数调用，<strong>native</strong>层的<strong>Looper</strong>实现了一整套完整的消息处理机制。但是<strong>Java</strong>层的<strong>Looper</strong>类和<strong>native</strong>层的<strong>Looper</strong>类并没有直接的关系。<strong>MessageQueue</strong>虽然使用了<strong>Native</strong>层的<strong>Looper</strong>类，但只用到了<strong>等待/唤醒机制</strong>，其余的如消息队列的实现还是在<strong>Java</strong>层。</p>
</blockquote>
<h2 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//调用本地方法等待nextPollTimeoutMillis秒，-1表示永远阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">		<span class="comment">//针对this对象同步，只要next方法没退出，再调用本对象的任何方法都将导致调用线程挂起</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  忽略普通消息，查找下一条异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//如果还没有处理这条消息的时间，计算等待时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;  <span class="comment">//取消阻塞的标志</span></span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果退出标志设置了，销毁native对象 </span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//检查是否安装了idle handler</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">//如果又idle handler ，循环继续，而不是阻塞</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向MessageQueue发消息"><a href="#向MessageQueue发消息" class="headerlink" title="向MessageQueue发消息"></a>向MessageQueue发消息</h2><p>使用的是**enqueueMessage()**方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果消息的target为NULL，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//如果加入的是正在处理的消息对象，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//用this对象同步</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;<span class="comment">//p指向消息队列头</span></span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg; <span class="comment">//把消息插到队列头</span></span><br><span class="line">            needWake = mBlocked;<span class="comment">//这时如果处理线程阻塞了，则需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//如果设置了“SyncBarrier”，只有插入了“异步消息”才需要唤醒</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//如果已经一条“异步消息”在队列里了，而且在本条消息前处理，而不需要唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;<span class="comment">//如果需要唤醒，则唤醒线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>enqueueMessage()<strong>方法插入消息时根据时间来排序，时间早的插在前面。消息队列的组织利用了</strong>Message</strong>类里面的<strong>next</strong>指针形成一个从头指向尾的单向链表。插入时计算是否需要唤醒处理。**enqueueMessage()**方法会尽量避免唤醒处理线程，只有插入了一条马上要处理的消息，或者在暂停处理消息的情况下，有插入了“异步消息”的情况下才会去唤醒处理线程。其余的情况都是把消息放到队列的中部或尾部（时间未到）。如果前面还有消息没处理，这条消息就更不急于处理了。</p>
<h1 id="Hander类"><a href="#Hander类" class="headerlink" title="Hander类"></a>Hander类</h1><h2 id="构造Handler"><a href="#构造Handler" class="headerlink" title="构造Handler"></a>构造Handler</h2><p>构造一个<strong>Handler</strong>对象需要两个参数，线程的<strong>Looper</strong>对象和消息的处理函数。<strong>Looper</strong>是必须的，构造方法不指定则使用当前线程的<strong>Looper</strong>对象。但是<strong>callback</strong>不是必须的，可以用<strong>callback</strong>实现对消息的集中处理，也可以把处理消息的<strong>callback</strong>方法放在消息对象中。</p>
<h3 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mLooper = Looper.myLooper(); <span class="comment">//从sThreadLocal中获取Looper对象,下面Looper中的函数可以看到</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue; <span class="comment">//消息队列，来自Looper对象</span></span><br><span class="line">    mCallback = callback;  <span class="comment">//回调方法</span></span><br><span class="line">    mAsynchronous = async; <span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper类中的方法，见2.3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;	<span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;  <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">       	……</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的<strong>send</strong>消息都调用了<strong>enqueueMessage()<strong>方法,最终调用了</strong>MessageQueue</strong>中的<strong>enqueueMessage()<strong>方法，就是把消息加入到了消息队列，并指定执行的时间。可以看到下面</strong>queue.enqueueMessage()<strong>方法中除了</strong>msg</strong>，只有<strong>时间</strong>。上述一系列的<strong>send</strong>方法只是为了方便使用，可以从方法名中看出各自的使用情景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line"> 	msg.target = <span class="keyword">this</span>;</span><br><span class="line"> 	<span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">     	msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上看这些<strong>post</strong>方法的实现也是用<strong>send</strong>，只是多了<strong>Runnable</strong>对象，然后调用<strong>getPostMessage()<strong>方法获取一个</strong>Message</strong>对象来发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">	Message m = Message.obtain();</span><br><span class="line"> 	m.callback = r;<span class="comment">//这里callback被携带在message中，参见3.1</span></span><br><span class="line"> 	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line"> 	Message m = Message.obtain();</span><br><span class="line"> 	m.obj = token;</span><br><span class="line"> 	m.callback = r;</span><br><span class="line"> 	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatchMessage-方法"><a href="#dispatchMessage-方法" class="headerlink" title="dispatchMessage()方法"></a>dispatchMessage()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);<span class="comment">//message中的callback</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//Handler构造时，指定的callback </span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);<span class="comment">//Handler默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到消息分发的优先级：</p>
<ol>
<li>Message的回调方法：message.callback；</li>
<li>Handler的回调方法：Handler.mCallback.handleMessage(msg)；</li>
<li>Handler的默认方法：Handler.handleMessage(msg)。</li>
</ol>
<p><strong>dispatchMessage()方法的调用在Looper类中的loop()方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;<span class="comment">//见2.4</span></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     ……</span><br><span class="line">     msg.target.dispatchMessage(msg);<span class="comment">//消息分发</span></span><br><span class="line">	 ……</span><br><span class="line">     msg.recycleUnchecked();<span class="comment">//消息回收</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>  <img src="/2016/08/27/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.png" alt="Android消息机制"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="http://gityuan.com/2015/12/26/handler-message-framework/">http://gityuan.com/2015/12/26/handler-message-framework/</a></p>
<p>[2] <a href="http://yuqiangqiang.com/2014/11/08/android%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/9-android%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/">http://yuqiangqiang.com/2014/11/08/android基础总结/9-android下的Handler机制/</a></p>
<p>[3] <a href="http://www.kancloud.cn/digest/androidfrom-0/144443">http://www.kancloud.cn/digest/androidfrom-0/144443</a></p>
<p>[4] <a href="https://developer.android.com/training/multiple-threads/communicate-ui.html">https://developer.android.com/training/multiple-threads/communicate-ui.html</a></p>
<p>[5] <a href="https://blog.nikitaog.me/2014/10/11/android-looper-handler-handlerthread-i/">https://blog.nikitaog.me/2014/10/11/android-looper-handler-handlerthread-i/</a></p>
<p>[6] <a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/14/2174255.html#!comments">http://www.cnblogs.com/codingmyworld/archive/2011/09/14/2174255.html#!comments</a></p>
<p>[7] <a href="http://www.jianshu.com/p/02962454adf7">http://www.jianshu.com/p/02962454adf7</a></p>
<p>[8] <a href="http://www.feeyan.cn/?p=17">http://www.feeyan.cn/?p=17</a></p>
<p>[9] <a href="http://anany.me/2015/04/12/handler/">http://anany.me/2015/04/12/handler/</a></p>
<p>[10] <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce">http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce</a></p>
<p>[11] <a href="https://www.zhihu.com/question/34652589">https://www.zhihu.com/question/34652589</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
